// File generated by the BNF Converter (bnfc 2.9.6).

package ru.itmo.stella.lang.stella;

/*** Visitor Design Pattern Skeleton. ***/

/* This implements the common visitor design pattern.
   Tests show it to be slightly less efficient than the
   instanceof method, but easier to use.
   Replace the R and A parameters with the desired return
   and context types.*/

public class VisitSkel
{
  public class ProgramVisitor<R,A> implements ru.itmo.stella.lang.Absyn.Program.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.AProgram p, A arg)
    { /* Code for AProgram goes here */
      p.languagedecl_.accept(new LanguageDeclVisitor<R,A>(), arg);
      for (ru.itmo.stella.lang.Absyn.Extension x: p.listextension_) {
        x.accept(new ExtensionVisitor<R,A>(), arg);
      }
      for (ru.itmo.stella.lang.Absyn.Decl x: p.listdecl_) {
        x.accept(new DeclVisitor<R,A>(), arg);
      }
      return null;
    }
  }
  public class LanguageDeclVisitor<R,A> implements ru.itmo.stella.lang.Absyn.LanguageDecl.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.LanguageCore p, A arg)
    { /* Code for LanguageCore goes here */
      return null;
    }
  }
  public class ExtensionVisitor<R,A> implements ru.itmo.stella.lang.Absyn.Extension.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.AnExtension p, A arg)
    { /* Code for AnExtension goes here */
      for (String x: p.listextensionname_) {
        //x;
      }
      return null;
    }
  }
  public class DeclVisitor<R,A> implements ru.itmo.stella.lang.Absyn.Decl.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.DeclFun p, A arg)
    { /* Code for DeclFun goes here */
      for (ru.itmo.stella.lang.Absyn.Annotation x: p.listannotation_) {
        x.accept(new AnnotationVisitor<R,A>(), arg);
      }
      //p.stellaident_;
      for (ru.itmo.stella.lang.Absyn.ParamDecl x: p.listparamdecl_) {
        x.accept(new ParamDeclVisitor<R,A>(), arg);
      }
      p.returntype_.accept(new ReturnTypeVisitor<R,A>(), arg);
      p.throwtype_.accept(new ThrowTypeVisitor<R,A>(), arg);
      for (ru.itmo.stella.lang.Absyn.Decl x: p.listdecl_) {
        x.accept(new DeclVisitor<R,A>(), arg);
      }
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.DeclFunGeneric p, A arg)
    { /* Code for DeclFunGeneric goes here */
      for (ru.itmo.stella.lang.Absyn.Annotation x: p.listannotation_) {
        x.accept(new AnnotationVisitor<R,A>(), arg);
      }
      //p.stellaident_;
      for (String x: p.liststellaident_) {
        //x;
      }
      for (ru.itmo.stella.lang.Absyn.ParamDecl x: p.listparamdecl_) {
        x.accept(new ParamDeclVisitor<R,A>(), arg);
      }
      p.returntype_.accept(new ReturnTypeVisitor<R,A>(), arg);
      p.throwtype_.accept(new ThrowTypeVisitor<R,A>(), arg);
      for (ru.itmo.stella.lang.Absyn.Decl x: p.listdecl_) {
        x.accept(new DeclVisitor<R,A>(), arg);
      }
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.DeclTypeAlias p, A arg)
    { /* Code for DeclTypeAlias goes here */
      //p.stellaident_;
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.DeclExceptionType p, A arg)
    { /* Code for DeclExceptionType goes here */
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.DeclExceptionVariant p, A arg)
    { /* Code for DeclExceptionVariant goes here */
      //p.stellaident_;
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class LocalDeclVisitor<R,A> implements ru.itmo.stella.lang.Absyn.LocalDecl.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.ALocalDecl p, A arg)
    { /* Code for ALocalDecl goes here */
      p.decl_.accept(new DeclVisitor<R,A>(), arg);
      return null;
    }
  }
  public class AnnotationVisitor<R,A> implements ru.itmo.stella.lang.Absyn.Annotation.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.InlineAnnotation p, A arg)
    { /* Code for InlineAnnotation goes here */
      return null;
    }
  }
  public class ParamDeclVisitor<R,A> implements ru.itmo.stella.lang.Absyn.ParamDecl.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.AParamDecl p, A arg)
    { /* Code for AParamDecl goes here */
      //p.stellaident_;
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class ReturnTypeVisitor<R,A> implements ru.itmo.stella.lang.Absyn.ReturnType.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.NoReturnType p, A arg)
    { /* Code for NoReturnType goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.SomeReturnType p, A arg)
    { /* Code for SomeReturnType goes here */
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class ThrowTypeVisitor<R,A> implements ru.itmo.stella.lang.Absyn.ThrowType.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.NoThrowType p, A arg)
    { /* Code for NoThrowType goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.SomeThrowType p, A arg)
    { /* Code for SomeThrowType goes here */
      for (ru.itmo.stella.lang.Absyn.Type x: p.listtype_) {
        x.accept(new TypeVisitor<R,A>(), arg);
      }
      return null;
    }
  }
  public class TypeVisitor<R,A> implements ru.itmo.stella.lang.Absyn.Type.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.TypeAuto p, A arg)
    { /* Code for TypeAuto goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeFun p, A arg)
    { /* Code for TypeFun goes here */
      for (ru.itmo.stella.lang.Absyn.Type x: p.listtype_) {
        x.accept(new TypeVisitor<R,A>(), arg);
      }
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeForAll p, A arg)
    { /* Code for TypeForAll goes here */
      for (String x: p.liststellaident_) {
        //x;
      }
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeRec p, A arg)
    { /* Code for TypeRec goes here */
      //p.stellaident_;
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeSum p, A arg)
    { /* Code for TypeSum goes here */
      p.type_1.accept(new TypeVisitor<R,A>(), arg);
      p.type_2.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeTuple p, A arg)
    { /* Code for TypeTuple goes here */
      for (ru.itmo.stella.lang.Absyn.Type x: p.listtype_) {
        x.accept(new TypeVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeRecord p, A arg)
    { /* Code for TypeRecord goes here */
      for (ru.itmo.stella.lang.Absyn.RecordFieldType x: p.listrecordfieldtype_) {
        x.accept(new RecordFieldTypeVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeVariant p, A arg)
    { /* Code for TypeVariant goes here */
      for (ru.itmo.stella.lang.Absyn.VariantFieldType x: p.listvariantfieldtype_) {
        x.accept(new VariantFieldTypeVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeList p, A arg)
    { /* Code for TypeList goes here */
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeBool p, A arg)
    { /* Code for TypeBool goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeNat p, A arg)
    { /* Code for TypeNat goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeUnit p, A arg)
    { /* Code for TypeUnit goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeTop p, A arg)
    { /* Code for TypeTop goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeBottom p, A arg)
    { /* Code for TypeBottom goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeRef p, A arg)
    { /* Code for TypeRef goes here */
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeVar p, A arg)
    { /* Code for TypeVar goes here */
      //p.stellaident_;
      return null;
    }
  }
  public class MatchCaseVisitor<R,A> implements ru.itmo.stella.lang.Absyn.MatchCase.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.AMatchCase p, A arg)
    { /* Code for AMatchCase goes here */
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
  }
  public class OptionalTypingVisitor<R,A> implements ru.itmo.stella.lang.Absyn.OptionalTyping.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.NoTyping p, A arg)
    { /* Code for NoTyping goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.SomeTyping p, A arg)
    { /* Code for SomeTyping goes here */
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class PatternDataVisitor<R,A> implements ru.itmo.stella.lang.Absyn.PatternData.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.NoPatternData p, A arg)
    { /* Code for NoPatternData goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.SomePatternData p, A arg)
    { /* Code for SomePatternData goes here */
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      return null;
    }
  }
  public class ExprDataVisitor<R,A> implements ru.itmo.stella.lang.Absyn.ExprData.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.NoExprData p, A arg)
    { /* Code for NoExprData goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.SomeExprData p, A arg)
    { /* Code for SomeExprData goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
  }
  public class PatternVisitor<R,A> implements ru.itmo.stella.lang.Absyn.Pattern.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.PatternCastAs p, A arg)
    { /* Code for PatternCastAs goes here */
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternAsc p, A arg)
    { /* Code for PatternAsc goes here */
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternVariant p, A arg)
    { /* Code for PatternVariant goes here */
      //p.stellaident_;
      p.patterndata_.accept(new PatternDataVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternInl p, A arg)
    { /* Code for PatternInl goes here */
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternInr p, A arg)
    { /* Code for PatternInr goes here */
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternTuple p, A arg)
    { /* Code for PatternTuple goes here */
      for (ru.itmo.stella.lang.Absyn.Pattern x: p.listpattern_) {
        x.accept(new PatternVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternRecord p, A arg)
    { /* Code for PatternRecord goes here */
      for (ru.itmo.stella.lang.Absyn.LabelledPattern x: p.listlabelledpattern_) {
        x.accept(new LabelledPatternVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternList p, A arg)
    { /* Code for PatternList goes here */
      for (ru.itmo.stella.lang.Absyn.Pattern x: p.listpattern_) {
        x.accept(new PatternVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternCons p, A arg)
    { /* Code for PatternCons goes here */
      p.pattern_1.accept(new PatternVisitor<R,A>(), arg);
      p.pattern_2.accept(new PatternVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternFalse p, A arg)
    { /* Code for PatternFalse goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternTrue p, A arg)
    { /* Code for PatternTrue goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternUnit p, A arg)
    { /* Code for PatternUnit goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternInt p, A arg)
    { /* Code for PatternInt goes here */
      //p.integer_;
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternSucc p, A arg)
    { /* Code for PatternSucc goes here */
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.PatternVar p, A arg)
    { /* Code for PatternVar goes here */
      //p.stellaident_;
      return null;
    }
  }
  public class LabelledPatternVisitor<R,A> implements ru.itmo.stella.lang.Absyn.LabelledPattern.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.ALabelledPattern p, A arg)
    { /* Code for ALabelledPattern goes here */
      //p.stellaident_;
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      return null;
    }
  }
  public class BindingVisitor<R,A> implements ru.itmo.stella.lang.Absyn.Binding.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.ABinding p, A arg)
    { /* Code for ABinding goes here */
      //p.stellaident_;
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
  }
  public class ExprVisitor<R,A> implements ru.itmo.stella.lang.Absyn.Expr.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.Sequence p, A arg)
    { /* Code for Sequence goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Let p, A arg)
    { /* Code for Let goes here */
      for (ru.itmo.stella.lang.Absyn.PatternBinding x: p.listpatternbinding_) {
        x.accept(new PatternBindingVisitor<R,A>(), arg);
      }
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.LetRec p, A arg)
    { /* Code for LetRec goes here */
      for (ru.itmo.stella.lang.Absyn.PatternBinding x: p.listpatternbinding_) {
        x.accept(new PatternBindingVisitor<R,A>(), arg);
      }
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeAbstraction p, A arg)
    { /* Code for TypeAbstraction goes here */
      for (String x: p.liststellaident_) {
        //x;
      }
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Assign p, A arg)
    { /* Code for Assign goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.If p, A arg)
    { /* Code for If goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      p.expr_3.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.LessThan p, A arg)
    { /* Code for LessThan goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.LessThanOrEqual p, A arg)
    { /* Code for LessThanOrEqual goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.GreaterThan p, A arg)
    { /* Code for GreaterThan goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.GreaterThanOrEqual p, A arg)
    { /* Code for GreaterThanOrEqual goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Equal p, A arg)
    { /* Code for Equal goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.NotEqual p, A arg)
    { /* Code for NotEqual goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeAsc p, A arg)
    { /* Code for TypeAsc goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeCast p, A arg)
    { /* Code for TypeCast goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Abstraction p, A arg)
    { /* Code for Abstraction goes here */
      for (ru.itmo.stella.lang.Absyn.ParamDecl x: p.listparamdecl_) {
        x.accept(new ParamDeclVisitor<R,A>(), arg);
      }
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Variant p, A arg)
    { /* Code for Variant goes here */
      //p.stellaident_;
      p.exprdata_.accept(new ExprDataVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Match p, A arg)
    { /* Code for Match goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      for (ru.itmo.stella.lang.Absyn.MatchCase x: p.listmatchcase_) {
        x.accept(new MatchCaseVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.List p, A arg)
    { /* Code for List goes here */
      for (ru.itmo.stella.lang.Absyn.Expr x: p.listexpr_) {
        x.accept(new ExprVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Add p, A arg)
    { /* Code for Add goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Subtract p, A arg)
    { /* Code for Subtract goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.LogicOr p, A arg)
    { /* Code for LogicOr goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Multiply p, A arg)
    { /* Code for Multiply goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Divide p, A arg)
    { /* Code for Divide goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.LogicAnd p, A arg)
    { /* Code for LogicAnd goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Ref p, A arg)
    { /* Code for Ref goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Deref p, A arg)
    { /* Code for Deref goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Application p, A arg)
    { /* Code for Application goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      for (ru.itmo.stella.lang.Absyn.Expr x: p.listexpr_) {
        x.accept(new ExprVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TypeApplication p, A arg)
    { /* Code for TypeApplication goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      for (ru.itmo.stella.lang.Absyn.Type x: p.listtype_) {
        x.accept(new TypeVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.DotRecord p, A arg)
    { /* Code for DotRecord goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      //p.stellaident_;
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.DotTuple p, A arg)
    { /* Code for DotTuple goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      //p.integer_;
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Tuple p, A arg)
    { /* Code for Tuple goes here */
      for (ru.itmo.stella.lang.Absyn.Expr x: p.listexpr_) {
        x.accept(new ExprVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Record p, A arg)
    { /* Code for Record goes here */
      for (ru.itmo.stella.lang.Absyn.Binding x: p.listbinding_) {
        x.accept(new BindingVisitor<R,A>(), arg);
      }
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.ConsList p, A arg)
    { /* Code for ConsList goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Head p, A arg)
    { /* Code for Head goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.IsEmpty p, A arg)
    { /* Code for IsEmpty goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Tail p, A arg)
    { /* Code for Tail goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Panic p, A arg)
    { /* Code for Panic goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Throw p, A arg)
    { /* Code for Throw goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TryCatch p, A arg)
    { /* Code for TryCatch goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TryWith p, A arg)
    { /* Code for TryWith goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.TryCastAs p, A arg)
    { /* Code for TryCastAs goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      p.expr_3.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Inl p, A arg)
    { /* Code for Inl goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Inr p, A arg)
    { /* Code for Inr goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Succ p, A arg)
    { /* Code for Succ goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.LogicNot p, A arg)
    { /* Code for LogicNot goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Pred p, A arg)
    { /* Code for Pred goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.IsZero p, A arg)
    { /* Code for IsZero goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Fix p, A arg)
    { /* Code for Fix goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.NatRec p, A arg)
    { /* Code for NatRec goes here */
      p.expr_1.accept(new ExprVisitor<R,A>(), arg);
      p.expr_2.accept(new ExprVisitor<R,A>(), arg);
      p.expr_3.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Fold p, A arg)
    { /* Code for Fold goes here */
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Unfold p, A arg)
    { /* Code for Unfold goes here */
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.ConstTrue p, A arg)
    { /* Code for ConstTrue goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.ConstFalse p, A arg)
    { /* Code for ConstFalse goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.ConstUnit p, A arg)
    { /* Code for ConstUnit goes here */
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.ConstInt p, A arg)
    { /* Code for ConstInt goes here */
      //p.integer_;
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.ConstMemory p, A arg)
    { /* Code for ConstMemory goes here */
      //p.memoryaddress_;
      return null;
    }
    public R visit(ru.itmo.stella.lang.Absyn.Var p, A arg)
    { /* Code for Var goes here */
      //p.stellaident_;
      return null;
    }
  }
  public class PatternBindingVisitor<R,A> implements ru.itmo.stella.lang.Absyn.PatternBinding.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.APatternBinding p, A arg)
    { /* Code for APatternBinding goes here */
      p.pattern_.accept(new PatternVisitor<R,A>(), arg);
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      return null;
    }
  }
  public class VariantFieldTypeVisitor<R,A> implements ru.itmo.stella.lang.Absyn.VariantFieldType.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.AVariantFieldType p, A arg)
    { /* Code for AVariantFieldType goes here */
      //p.stellaident_;
      p.optionaltyping_.accept(new OptionalTypingVisitor<R,A>(), arg);
      return null;
    }
  }
  public class RecordFieldTypeVisitor<R,A> implements ru.itmo.stella.lang.Absyn.RecordFieldType.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.ARecordFieldType p, A arg)
    { /* Code for ARecordFieldType goes here */
      //p.stellaident_;
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
  public class TypingVisitor<R,A> implements ru.itmo.stella.lang.Absyn.Typing.Visitor<R,A>
  {
    public R visit(ru.itmo.stella.lang.Absyn.ATyping p, A arg)
    { /* Code for ATyping goes here */
      p.expr_.accept(new ExprVisitor<R,A>(), arg);
      p.type_.accept(new TypeVisitor<R,A>(), arg);
      return null;
    }
  }
}
